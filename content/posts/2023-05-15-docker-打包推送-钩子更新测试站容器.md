---
title: "docker 打包推送 + 钩子更新测试站容器"
date: 2023-05-15T16:48:15+08:00
updated: 2026-02-23T04:03:15+08:00
author: "臭大佬"
categories: [linux]
description: "docker 打包推送 + 钩子更新测试站容器"
cover: "https://www.choudalao.com/uploads/20230515/xp5e9eyWyNuVlN5gsjKacrg8rXYLYy2r1eNmeAaw.png"
click: 3755
---

# 问题
刚开始测试站更新的流程如下:
- 本地构建`go`项目
- 本地打包镜像
- 本地推送镜像库
- 到测试服务器上,拉取镜像

每次都要这么繁琐的操作,也是有点累,所以准备做一个升级,一步到位,思路如下
本地写一个脚本,主要是为了构建项目和推送镜像到远程仓库,然后测试站通过钩子触发更新镜像.


# 方案
本地脚本 docker_build.sh
```go
#!/bin/bash

# 项目
obj="admin"
# 根据分支推送打包
branch=$(git symbolic-ref --short HEAD)
if [ "$branch" = "develop" ]; then
  env="test"
elif [ "$branch" = "master" ]; then
  env="prod"
else
  echo "请在 develop 上运行脚本, 当前分支:" $branch
  exit 0
fi

if [ ! $env ]; then
  echo "运行条件不能为空"
  exit
fi

if [[ $env != "dev" && $env != "prod" && $env != "test" ]]; then
  echo "运行条件错误"
  exit 0
fi

echo "----- ${obj}: 重构镜像 -----"
echo "项目:" $obj
echo "环境:" $env
echo "git分支:" $branch

# 提交时转换为LF，检出时转换为LF
# git config core.autocrlf true
git pull origin "$branch"

# 遍历子模块
echo "拉取子包"
git submodule foreach --recursive "git checkout master -f && git pull"
# git submodule update --remote

docker-compose -f docker-compose-$env.yml build

echo "删除容器"

docker rm containerID

echo "删除旧的tag包"

docker image rm registry.example.com/containerID:$env

echo "打标签"

docker tag containerID:$env registry.example.com/containerID:$env

echo "推送到远程仓库"

docker push registry.example.com/containerID:$env

# curl请求触发更新
whUrl="http://xxx.com/webhook.php?branch=${branch}&obj=${obj}"
echo "请求地址:${whUrl}"
curl -X GET ${whUrl}


```
注释:
registry.example.com :仓库地址
branch:分支名,这里限制只能在develop和master分支触发打包
env: docker镜像的版本
obj: 项目
containerID: 容器ID


服务器上的webhook脚本 webhook.php
```go
<?php

// 获取请求参数
$obj = $_GET["obj"];
$branch = $_GET["branch"];
// 如果有需要 可以打开下面，把传送过来的信息写进log 可用于调试，测试成功后注释即可

// 如果是develop分支
if (strpos($branch, "develop") === false) {
    echo $branch;
    return false;
}
// 更新的环境
$objArr = ["bus","admin","user","im"];
if ( !in_array($obj,$objArr)) {
    echo $obj;
    return false;
}

// 打开网站目录下的hooks.log文件 需要在服务器上创建 并给写权限
$fs = fopen('./webhooks_pull_' . date("m_d") . '.log', 'a');
fwrite($fs, '================ Update Start '.date("H:i:s") .'===============' . PHP_EOL . PHP_EOL);

fwrite($fs, 'obj: ' . $obj . PHP_EOL);
fwrite($fs, 'branch: ' . $branch . PHP_EOL);

// 执行shell命令,cd到网站根目录，执行git pull进行拉取代码，并把返回信息写进日志
fwrite($fs, '脚本:' . 'sh /www/'.$obj.'/run.sh;' . PHP_EOL);
exec('sh /www/'.$obj.'/run.sh 2>&1', $output,$return_var);
fwrite($fs, 'Info:' . print_r($output, true) . PHP_EOL);
fwrite($fs, 'Return:' . $return_var . PHP_EOL);
fwrite($fs, PHP_EOL . '================ Update End ===============' . PHP_EOL . PHP_EOL);
$fs and fclose($fs);

```
测试站中的run.sh 脚本:
```go
#!/bin/bash

show_usage="args:[-e: dev,test,prod] [-j:Your Project Name] [-p: Port]"

#获取参数
while [ -n "$1" ]; do
  case "$1" in -e)
    env=$2
    shift 2
    ;;
  --) break ;;
  *)
    echo -e "unsupported arg:$1,$2","\n$show_usage"
    break
    ;;
  esac
done
#写死环境 也可以根据上面的参数来
env="test"
if [ ! $env ]; then
  echo "运行条件不能为空"
  exit
fi

if [[ $env != "dev" && $env != "prod" && $env != "test" ]]; then
  echo "运行条件错误"
  exit 0
fi

# 密码登陆 username改成自己的账号
echo "密码" | docker login -u username --password-stdin registry.example.com

echo "停止 containerID 容器运行"
docker stop containerID
echo  "删除 containerID 容器"
docker rm containerID

#echo "删除镜像"
# docker image rm registry.example.com/containerID:$env
echo "拉取镜像"
docker pull registry.example.com/containerID:$env

echo "新建容器"
docker run -itd -p 31000:31000 -v /www/temp:/containerID/temp --name containerID registry.example.com/containerID:$env

# ---- 再做一个容器做负载 start-----
echo "停止 containerID-1 容器运行"
docker stop containerID-1
echo  "删除 containerID-1 容器"
docker rm containerID-1

echo "新建容器-1"
docker run -itd -p 31001:31000 -v /www/temp1:/containerID/temp --name containerID-1 registry.example.com/containerID:$env

# ---- 再做一个容器做负载 end-----

echo "删除tag为none的镜像"
docker images|grep none|awk '{print $3}'|xargs docker rmi

```
注意:上面只是一个例子,存在安全风险,请自行增加验证流程,做好防护措施.
# 总结
本地运行`sh docker_build.sh`完成打包和推送镜像,还有触发了webhook的钩子,服务器就会去执行拉取镜像和更新的操作,至于gitwebhook的配置,可以自行百度.

## 问题
这边使用php做的webhook,可能会没有权限操作 docker,
将 www 添加到 docker 用户组中
```go
sudo usermod -aG docker www
```
将文件的所属用户改为 root，所属群组改为 docker，并增加了群组读写权限rw。
```go
sudo chown www:docker /var/run/docker.sock
```
```go
sudo chmod g+rw /var/run/docker.sock
```
查询当前用户所属的用户组
```go
groups www
```
查询 docker 用户组中包含的所有用户
```go
cat /etc/group | grep docker
```