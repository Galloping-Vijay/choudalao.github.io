---
title: "MYSQL 慢查询 | 臭大佬"
date: 2020-09-07T11:28:11+08:00
updated: 2026-02-23T19:59:06+08:00
author: "臭大佬"
categories: [MYSQL]
description: "MYSQL 慢查询"
cover: "https://www.choudalao.com/uploads/20200907/OJH3CaLS0zlFucAGxpy8v0qn0u0lVt25s3nfwAK4.jpeg"
click: 3464
---

# 数据库中设置SQL慢查询
###  一、第一步.开启mysql慢查询  
 查看MySQL是否启用了查看慢SQL的日志文件
####（1） 查看慢SQL日志是否启用
```shell
mysql> show variables like 'log_slow_queries'; 
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| log_slow_queries | ON    |
+------------------+-------+
1 row in set (0.00 sec)

```


#### （2） 查看执行慢于多少秒的SQL会记录到日志文件中
```shell
mysql> show variables like 'long_query_time';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| long_query_time | 1     |   
+-----------------+-------+
1 row in set (0.00 sec)
这里value=1， 表示1秒
```

### 二. 配置my.ini文件（inux下文件名为my.cnf）， 查找到[mysqld]区段，增加日志的配置，如下示例：
```shell
[mysqld]
log="C:/temp/mysql.log"
log_slow_queries="C:/temp/mysql_slow.log"
long_query_time=1
log指示日志文件存放目录；
log_slow_queries指示记录执行时间长的sql日志目录；
long_query_time指示多长时间算是执行时间长，单位s。
```

Linux下这些配置项应该已经存在，只是被注释掉了，可以去掉注释。但直接添加配置项也OK啦。


# MySQL的Explain关键字查看是否使用索引
##### select_type列：数据读取操作的操作类型
　　1、SIMPLE:简单的select 查询，SQL中不包含子查询或者UNION。
　　2、PRIMARY:查询中包含复杂的子查询部分，最外层查询被标记为PRIMARY
　　3、SUBQUERY:在select 或者WHERE 列表中包含了子查询
　　4、DERIVED:在FROM列表中包含的子查询会被标记为DERIVED(衍生表)，MYSQL会递归执行这些子查询，把结果集放到零时表中。
　　5、UNION:如果第二个SELECT 出现在UNION之后，则被标记位UNION；如果UNION包含在FROM子句的子查询中，则外层SELECT 将被标记为DERIVED
　　6、UNION RESULT:从UNION表获取结果的select
##### table列：该行数据是关于哪张表
##### type列：访问类型  由好到差system > const > eq_ref > ref > range > index > ALL
　　1、system:表只有一条记录(等于系统表),这是const类型的特例，平时业务中不会出现。
　　2、const:通过索引一次查到数据，该类型主要用于比较primary key 或者unique 索引，因为只匹配一行数据，所以很快;如果将主键置于WHERE语句后面，Mysql就能将该查询转换为一个常量。 
　　3、eq_ref:唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。
　　4、ref:非唯一索引扫描，返回匹配某个单独值得所有行，本质上是一种索引访问，它返回所有匹配某个单独值的行，就是说它可能会找到多条符合条件的数据，所以他是查找与扫描的混合体。
　　5、range：只检索给定范围的行，使用一个索引来选着行。key列显示使用了哪个索引。一般在你的WHERE 语句中出现between 、< 、> 、in 等查询，这种给定范围扫描比全表扫描要好。因为他只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。
　　6、index：FUll Index Scan 扫描遍历索引树(扫描全表的索引，从索引中获取数据)。
　　7、ALL 全表扫描 从磁盘中获取数据 百万级别的数据ALL类型的数据尽量优化。
##### possible_keys列:显示可能应用在这张表的索引，一个或者多个。查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用。
##### keys列:实际使用到的索引。如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅出现在key列表中。覆盖索引：select 后的 字段与我们建立索引的字段个数一致。
##### ken_len列:表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的。
##### ref列:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。
##### rows列(每张表有多少行被优化器查询):根据表统计信息及索引选用的情况，大致估算找到所需记录需要读取的行数。

# profile指令查询耗时情况
如果已经执行了SQL语句，那么可以输入show profiles查看; //profiles 是执行sql语句的记录表，里面有duration（持续时间）代表执行时间
如何看不到：则show variables; 查看profiling变量是否为on（也就是开启）状态；查看是否打开了profiles功能,默认是关闭的,如果是off, 则执行命令 set profiling=1;

执行完sql语句,使用
```go
show profiles
```

![](https://www.choudalao.com/uploads/20221227/20221227115805ipRKxO.png)