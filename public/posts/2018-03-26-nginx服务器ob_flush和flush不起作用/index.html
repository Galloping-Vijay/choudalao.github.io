<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>nginx服务器ob_flush和flush不起作用 - 臭大佬博客</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="nginx服务器ob_flush和flush不起作用"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=臭大佬博客 rel=home><div class="logo__item logo__text"><div class=logo__title>臭大佬博客</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>归档</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>nginx服务器ob_flush和flush不起作用</h1></header><div class="content post__content clearfix"><p>&lt;p>今天想做一个即时聊天的小应用,发现在nginx环境下,ob_flush不起作用,而apache没有问题,猜测应该是nginx的配置问题,代码如下:&lt;/p>&lt;pre lay-lang="PHP">&lt;code class="PHP">public function index()
{
if (ob_get_level() == 0) {
//判断缓冲区等级，如果没有活动缓冲区
ob_start(); //打开缓冲区
echo str_repeat(&rsquo;&rsquo;, 4096);
ob_end_flush();
ob_flush();
}
$i = 1;
while ($i &amp;lt;= 20) {
echo $i++;
echo str_pad(&rsquo;&rsquo;, 1025);
echo "
";</p><pre><code>    ob_flush();       //发送缓冲区数据
    flush();        //刷新缓冲区
    sleep(1);       //暂停1秒
}
</code></pre><p>}&lt;/code>&lt;/pre>&lt;p>&lt;strong>解决方案:&lt;/strong>&lt;br>&lt;/p>&lt;p>&lt;span style="text-align: justify;">检查nginx配置文件(nginx.conf)，禁用nginx的buffering：&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;/span>&lt;/p>&lt;pre lay-lang="PHP">&lt;code class="PHP"> #gzip on;</p><p>proxy_buffering off;</p><p>gzip off;</p><p>fastcgi_keep_conn on;&lt;/code>&lt;/pre>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;/span>&lt;/p>&lt;p style="text-align: justify;">检查php.ini，禁用buffering：&lt;/p>&lt;p style="text-align: justify;">output_buffering = off&lt;/p>&lt;p>&lt;span style="text-align: justify;">注意这句配置不能通过ini_set()函数动态在程序中设置，这在php官方手册中有说明：&lt;/span>&lt;br style="text-align: justify;">&lt;span style="text-align: justify;">the output_buffering setting is PHP_INI_PERDIR therefore it may not be set using ini_set()&lt;/span>&lt;br style="text-align: justify;">&lt;span style="text-align: justify;">经过上面两步的配置(nginx.conf和php.ini)后，重启nginx就可以了，再次测试文章开头的代码，成功逐行输出&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;/span>&lt;/p>&lt;p style="text-align: justify;">&lt;span>补充:PHP flush()与ob_flush()的区别&lt;/span>&lt;/p>&lt;p style="text-align: justify;">buffer &mdash;- flush()&lt;br>&amp;nbsp;&lt;br>buffer是一个内存地址空间,Linux系统默认大小一般为4096(1kb),即一个内存页。主要用于存储速度不同步的设备或者优先级不同的 设备之间传办理数据的区域。通过buffer，可以使进程这间的相互等待变少。这里说一个通俗一点的例子，你打开文本编辑器编辑一个文件的时候，你每输入 一个字符，操作系统并不会立即把这个字符直接写入到磁盘，而是先写入到buffer，当写满了一个buffer的时候，才会把buffer中的数据写入磁 盘，当然当调用内核函数flush()的时候，强制要求把buffer中的脏数据写回磁盘。&lt;br>同样的道理，当执行echo,print的时候，输出并没有立即通过tcp传给客户端浏览器显示, 而是将数据写入php buffer。php output_buffering机制，意味在tcp buffer之前，建立了一新的队列，数据必须经过该队列。当一个php buffer写满的时候，脚本进程会将php buffer中的输出数据交给系统内核交由tcp传给浏览器显示。所以，数据会依次写到这几个地方echo/pring -&amp;gt; php buffer -&amp;gt; tcp buffer -&amp;gt; browser&lt;/p>&lt;p style="text-align: justify;">&lt;span>php output_buffering &mdash; ob_flush()&lt;/span>&lt;/p>&lt;p style="text-align: justify;">默认情况下，php buffer是开启的，而且该buffer默认值是4096，即1kb。你可以通过在php.ini配置文件中找到output_buffering配置.当echo,print等输出用户数据的时候，输出数据都会写入到php output_buffering中，直到output_buffering写满，会将这些数据通过tcp传送给浏览器显示。你也可以通过 ob_start()手动激活php output_buffering机制，使得即便输出超过了1kb数据，也不真的把数据交给tcp传给浏览器，因为ob_start()将php buffer空间设置到了足够大 。只有直到脚本结束，或者调用ob_end_flush函数，才会把数据发送给客户端浏览器。&lt;/p>&lt;p style="text-align: justify;">&lt;br>这两个函数的使用怕是很多人最迷惑的一个问题，手册上对两个函数的解释也语焉不详，没有明确的指出它们的区别，似乎二者的功能都是刷新输出缓存。但在我们文章一开始的代码中如果讲fush()替换成ob_flush()，程序就再不能正确执行了。显然，它们是有区别的，否则也手册中直接说明其中一个是另外一个函数的别名即可了，没必要分别说明。那么它们的区别到底是什么呢？&lt;/p>&lt;p style="text-align: justify;">在没有开启缓存时，脚本输出的内容都在服务器端处于等待输出的状态 ，flush()可以将等待输出的内容立即发送到客户端。&lt;/p>&lt;p style="text-align: justify;">开启缓存后，脚本输出的内容存入了输出缓存中 ，这时没有处于等待输出状态的内容，你直接使用flush()不会向客户端发出任何内容。而 ob_flush()的作用就是将本来存在输出缓存中的内容取出来，设置为等待输出状态，但不会直接发送到客户端 ，这时你就需要先使用 ob_flush()再使用flush()，客户端才能立即获得脚本的输出。&lt;/p>&lt;p style="text-align: justify;">&lt;span>一. flush和ob_flush的正确顺序，正确应是，先ob_flush再flush，如下：&amp;nbsp;&lt;br>&lt;/span>ob_flush();&lt;br>flush();&lt;br>如果Web服务器的操作系统是windows系统，那顺序颠倒或者不使用ob_flush()也不会出现问题。[有待求证 ] 但是在Linux系统上就无法刷新输出缓冲。&lt;/p>&lt;p style="text-align: justify;">&lt;span>output buffering函数&lt;br>&lt;/span>1.bool ob_start ([ callback $output_callback [, int $chunk_size [, bool $erase ]]] )&lt;br>激活output_buffering机制。一旦激活，脚本输出不再直接出给浏览器，而是先暂时写入php buffer内存区域。&lt;br>php默认开启output_buffering机制，只不过，通过调用ob_start()函数据output_buffering值扩展到足够 大 。也可以指定$chunk_size来指定output_buffering的值。$chunk_size默认值是0,表示直到脚本运行结束，php buffer中的数据才会发送到浏览器。如果你设置了$chunk_size的大小 ，则表示只要buffer中数据长度达到了该值，就会将buffer中 的数据发送给浏览器。&lt;br>当然，你可以通过指定$ouput_callback，来处理buffer中的数据。比如函数ob_gzhandler，将buffer中的数据压缩后再传送给浏览器。&lt;br>第三个参数：是否擦除缓存，可选，默认是true，如果设置为false，则在脚本执行结束前，缓存都不会被清除。&lt;br>2.ob_get_contents&lt;br>获取一份php buffer中的数据拷贝。值得注意的是，你应该在ob_end_clean()函数调用前调用该函数，否则ob_get_contents()返回一个空字符中。&lt;/p>&lt;p style="text-align: justify;">可以使用ob_get_contents()以字符串形式获取服务端缓存的数据，&lt;br>使用ob_end_flush()则会输出被缓存起来的数据，并关闭缓存。&lt;br>而使用ob_end_clean()则会静默的清除服务端缓存的数据，而不会有任何数据或其他行为。&lt;br>服务端的缓存是堆叠起来的，也就是说你在开启了ob_start()后，关闭之前，在其内部还 可以开启另外一个缓存ob_start()。&lt;/p>&lt;p style="text-align: justify;">不过你也要务必保证关闭缓存的操作和开启缓存的操作数量一样多。&amp;nbsp;&lt;br>ob_start() 可以指定一个回调函数来处理缓存数据，如果一个ob_start()内部嵌套了另一个ob_start()，我们假定，外层的ob_start()，编号是A，内层的ob_start()编号是B，它们各自制定了一个回调函数分别是functionA和functionB，那么在缓存B中的数据输出时，它会先辈funcitonB回调函数处理，再交给外层的functionA回调函数处理，之后才能输出到客户端。&lt;/p>&lt;p style="text-align: justify;">另外，手册说，对于某些web服务器，比如apache，在使用回调函数有可能会改变程序当前的工作目录，解决方法是在回调函数中自行手动把工作目录修改回来，用chdir函数，这点似乎不常遇到，遇到的时候记得去查手册吧。&lt;/p>&lt;p style="text-align: justify;">&lt;span>3.ob_end_flush与ob_end_clean&lt;br>&lt;/span>这二个函数有点相似，都会关闭ouptu_buffering机制。但不同的是，ob_end_flush只是把php buffer中的数据冲(flush/send)到客户端浏览器，而ob_clean_clean将php bufeer中的数据清空(erase)，但不发送给客户端浏览器。&lt;/p>&lt;p style="text-align: justify;">ob_end_flush调用之前 ，php buffer中的数据依然存在，ob_get_contents()依然可以获取php buffer中的数据拷贝。&lt;/p>&lt;p style="text-align: justify;">而ob_end_flush()调用之后 ob_get_contents()取到的是空字符串，同时浏览器也接收不到输出，即没有任何输出。&lt;/p>&lt;p style="text-align: justify;">可以使用ob_get_contents()以字符串形式获取服务端缓存的数据，使用ob_end_flush()则会输出被缓存起来的数据，并关闭缓存。&lt;br>而使用ob_end_clean()则会静默的清除服务端缓存的数据，而不会有任何数据或其他行为。&lt;br>服务端的缓存是堆叠起来的，也就是说你在开启了ob_start()后，关闭之前，在其内部还可以开启另外一个缓存ob_start()。不过你也要务必保证关闭缓存的操作和开启缓存的操作数量一样多。&lt;br>ob_start() 可以指定一个回调函数来处理缓存数据，如果一个ob_start()内部嵌套了另一个ob_start()，我们假定，外层的ob_start()，编号是A，内层的ob_start()编号是B，它们各自制定了一个回调函数分别是functionA和functionB，那么在缓存B中的数据输出时，它会先辈funcitonB回调函数处理，再交给外层的functionA回调函数处理，之后才能输出到客户端。&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;br>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;/p>&lt;p>&lt;span style="text-align: justify;">&lt;br>&lt;/span>&lt;/p></p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2026 臭大佬博客.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> 主题</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>