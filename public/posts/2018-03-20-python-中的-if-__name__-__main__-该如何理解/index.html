<!doctype html><html class=no-js lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Python 中的 if __name__ == '__main__' 该如何理解 - 臭大佬博客</title><script>(function(e,t){e[t]=e[t].replace("no-js","js")})(document.documentElement,"className")</script><meta name=description content="Python 中的 if __name__ == '__main__' 该如何理解"><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=dns-prefetch href=//fonts.googleapis.com><link rel=dns-prefetch href=//fonts.gstatic.com><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/favicon.ico></head><body class=body><div class="container container--outer"><header class=header><div class="container header__container"><div class=logo><a class=logo__link href=/ title=臭大佬博客 rel=home><div class="logo__item logo__text"><div class=logo__title>臭大佬博客</div></div></a></div><nav class=menu><button class=menu__btn aria-haspopup=true aria-expanded=false tabindex=0>
<span class=menu__btn-title tabindex=-1>菜单</span></button><ul class=menu__list><li class=menu__item><a class=menu__link href=/><span class=menu__text>首页</span></a></li><li class=menu__item><a class=menu__link href=/post/><span class=menu__text>归档</span></a></li><li class=menu__item><a class=menu__link href=/about/><span class=menu__text>关于</span></a></li></ul></nav></div></header><div class="wrapper flex"><div class=primary><main class=main role=main><article class=post><header class=post__header><h1 class=post__title>Python 中的 if __name__ == '__main__' 该如何理解</h1></header><div class="content post__content clearfix"><p>&lt;h2 id="part-2da2d90c35afe693" style="text-align: justify;">程序入口&lt;/h2>&lt;p style="text-align: justify;">对于很多编程语言来说，程序都必须要有一个入口，比如 C，C++，以及完全面向对象的编程语言 Java，C# 等。如果你接触过这些语言，对于程序入口这个概念应该很好理解，C 和 C++ 都需要有一个 main 函数来作为程序的入口，也就是程序的运行会从 main 函数开始。同样，Java 和 C# 必须要有一个包含 Main 方法的主类来作为程序入口。&lt;/p>&lt;p style="text-align: justify;">而 Python 则有不同，它属于脚本语言，不像编译型语言那样先将程序编译成二进制再运行，而是动态的逐行解释运行。也就是从脚本第一行开始运行，没有统一的入口。&lt;/p>&lt;p style="text-align: justify;">一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，有一部分代码我们是不希望被运行的。&lt;/p>&lt;p style="text-align: justify;">举一个例子来说明一下，假设我们有一个 const.py 文件，内容如下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">PI = 3.14 def main(): print "PI:", PI main()&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">PI: 3.14&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">现在，我们有一个 area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area.py 中：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">from const import PI def calc_round_area(radius): return PI * (radius ** 2) def main(): print "round area: ", calc_round_area(2) main()&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">运行 area.py，输出结果：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">PI: 3.14 round area: 12.56&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">可以看到，const 中的 main 函数也被运行了，实际上我们是不希望它被运行，提供 main 也只是为了对常量定义进行下测试。这时，&lt;code>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;&lt;/code>&amp;nbsp;就派上了用场。把 const.py 改一下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">PI = 3.14 def main(): print "PI:", PI if <strong>name</strong> == "<strong>main</strong>": main()&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">然后再运行 area.py，输出如下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">round area: 12.56&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">再运行下 const.py，输出如下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">PI: 3.14&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">这才是我们想要的效果。&lt;/p>&lt;p style="text-align: justify;">&lt;code>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;&lt;/code>&amp;nbsp;就相当于是 Python&amp;nbsp;&lt;strong>模拟的程序入口&lt;/strong>。Python 本身并没有规定这么写，这只是一种编码习惯。由于模块之间相互引用，不同模块可能都有这样的定义，而入口程序只能有一个。到底哪个入口程序被选中，这取决于&amp;nbsp;&lt;code><strong>name</strong>&lt;/code>&amp;nbsp;的值。&lt;/p>&lt;h2 id="<strong>name</strong>" style="text-align: justify;"><strong>name</strong>&lt;/h2>&lt;p style="text-align: justify;">&lt;code><strong>name</strong>&lt;/code>&amp;nbsp;是内置变量，用于表示当前模块的名字，同时还能反映一个包的结构。来举个例子，假设有如下一个包：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">a ├── b │ ├── c.py │ └── <strong>init</strong>.py └── <strong>init</strong>.py&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">目录中所有 py 文件的内容都为：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">print <strong>name</strong>&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">我们执行&amp;nbsp;&lt;code>python -c "import a.b.c"&lt;/code>，输出结果：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">a a.b a.b.c&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">由此可见，&lt;code><strong>name</strong>&lt;/code>&amp;nbsp;可以清晰的反映一个模块在包中的层次。其实，所谓模块名就是 import 时需要用到的名字，例如：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">import tornado import tornado.web&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">这里的 tornado 和 tornado.web 就被称为模块的模块名。&lt;/p>&lt;p style="text-align: justify;">如果一个模块被直接运行，则其没有包结构，其&amp;nbsp;&lt;code><strong>name</strong>&lt;/code>&amp;nbsp;值为&amp;nbsp;&lt;code><strong>main</strong>&lt;/code>。例如在上例中，我们直接运行 c.py 文件（python a/b/c.py），输出结果如下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript"><strong>main</strong>&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">所以，&lt;code>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;&lt;/code>&amp;nbsp;我们简单的理解就是：&amp;nbsp;&lt;strong>如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行&lt;/strong>。&lt;/p>&lt;p style="text-align: justify;">实际上，这个问题还可以衍生出其他的一些知识点，例如&amp;nbsp;&lt;code><strong>main</strong>.py&lt;/code>&amp;nbsp;文件与 Python 的&amp;nbsp;&lt;code>-m&lt;/code>参数。&lt;/p>&lt;h2 id="<strong>main</strong>-py-python-m" style="text-align: justify;"><strong>main</strong>.py 文件与 python -m&lt;/h2>&lt;p style="text-align: justify;">Python 的&amp;nbsp;&lt;code>-m&lt;/code>&amp;nbsp;参数用于将一个模块或者包作为一个脚本运行，而&amp;nbsp;&lt;code><strong>main</strong>.py&lt;/code>&amp;nbsp;文件则相当于是一个包的”入口程序“。&lt;/p>&lt;p style="text-align: justify;">首先我们需要来看看&amp;nbsp;&lt;code>python xxx.py&lt;/code>&amp;nbsp;与&amp;nbsp;&lt;code>python -m xxx.py&lt;/code>&amp;nbsp;的区别。两种运行 Python 程序的方式的不同点在于，一种是直接运行，一种是当做模块来运行。&lt;/p>&lt;p style="text-align: justify;">先来看一个简单的例子，假设有一个 Python 文件 run.py，其内容如下：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">import sys print sys.path&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">我们用直接运行的方式启动（python run.py），输出结果(为了说明问题，输出结果只截取了重要部分，下同)：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">[&rsquo;/home/huoty/aboutme/pythonstudy/main&rsquo;, &mldr;]&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">然后以模块的方式运行（python -m run.py）:&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">[&rsquo;&rsquo;, &mldr;] /usr/bin/python: No module named run.py&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">由于输出结果只列出了关键的部分，应该很容易看出他们之间的差异。直接运行是把 run.py 文件所在的目录放到了 sys.path 属性中。以模块方式运行是把你输入命令的目录（也就是当前工作路径），放到了 sys.path 属性中。以模块方式运行还有一个不同的地方是，多出了一行&lt;code>No module named run.py&lt;/code>&amp;nbsp;的错误。实际上以模块方式运行时，Python 先对 run.py 执行一遍 import，所以&amp;nbsp;&lt;code>print sys.path&lt;/code>&amp;nbsp;被成功执行，然后 Python 才尝试运行 run.py 模块，但是，在 path 变量中并没有 run.py 这个模块，所以报错。而正确的运行方式，应该是&amp;nbsp;&lt;code>python -m run&lt;/code>.&lt;/p>&lt;p style="text-align: justify;">这个例子并不能明显的说明问题。接着我们来看看&amp;nbsp;&lt;code><strong>main</strong>.py&lt;/code>&amp;nbsp;的作用。&lt;/p>&lt;p style="text-align: justify;">仍然先看例子，有如下一个包：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">package ├── <strong>init</strong>.py └── <strong>main</strong>.py&lt;/code>&lt;/pre>&lt;ul class=" list-paddingleft-2" style="text-align: justify;">&lt;li>&lt;p><strong>init</strong>.py&lt;/p>&lt;/li>&lt;li>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">import sys print "<strong>init</strong>" print sys.path&lt;/code>&lt;/pre>&lt;/li>&lt;/ul>&lt;ul class=" list-paddingleft-2" style="text-align: justify;">&lt;li>&lt;p><strong>main</strong>.py&lt;/p>&lt;/li>&lt;li>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript">import sys print "<strong>main</strong>" print sys.path&lt;/code>&lt;/pre>&lt;/li>&lt;/ul>&lt;p style="text-align: justify;">用&amp;nbsp;&lt;code>python -m package&lt;/code>&amp;nbsp;运行结果：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript"><strong>init</strong> [&rsquo;&rsquo;, &mldr;] <strong>main</strong> [&rsquo;&rsquo;, &mldr;]&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">用&amp;nbsp;&lt;code>python package&lt;/code>&amp;nbsp;运行结果：&lt;/p>&lt;pre lay-lang="JavaScript">&lt;code class="JavaScript"><strong>main</strong> [&lsquo;package&rsquo;, &mldr;]&lt;/code>&lt;/pre>&lt;p style="text-align: justify;">然后我们来总结一下：&lt;/p>&lt;ul class=" list-paddingleft-2" style="text-align: justify;">&lt;li>&lt;p>1、&amp;nbsp;&lt;strong>加上 -m 参数时会把当前工作目录添加到 sys.path 中，而不加时则会把脚本所在目录添加到 sys.path 中&lt;/strong>。&lt;/p>&lt;/li>&lt;li>&lt;p>2、&amp;nbsp;&lt;strong>加上 -m 参数时 Python 会先将模块或者包导入，然后再执行&lt;/strong>&lt;/p>&lt;/li>&lt;li>&lt;p>3、&amp;nbsp;&lt;strong><strong>main</strong>.py 文件是一个包或者目录的入口程序。&lt;/strong>不管是用&amp;nbsp;&lt;code>python package&lt;/code>&amp;nbsp;还是用&lt;code>python -m package&lt;/code>&amp;nbsp;运行时，<strong>main</strong>.py 文件总是被执行。&lt;/p>&lt;/li>&lt;/ul>&lt;h2 id="part-654288be9d6" style="text-align: justify;">后序&lt;/h2>&lt;p style="text-align: justify;">我试图使用长篇大论来阐述，在 Python 中如何理解&amp;nbsp;&lt;code>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;&lt;/code>&amp;nbsp;这个问题，不知道我有没有描述得足够的明白。Python 的确是简单的，优雅的，但也有很多问题是不太容易理解的，例如很多高级的特性，像元类、生成器表达式、描述符、协程等。Python 并没有在太多的地方规定要如何如何，很多的用法只是惯用法，例如 self 和本文讨论的内容。这些用法或是为了让代码看起来更优雅，或是前人的经验。使用 Python 是有无限可能的，你可以写出很多简洁优雅的代码。&lt;/p>&lt;h2 id="part-2bb23717ee7e9bfc" style="text-align: justify;">参考资料&lt;/h2>&lt;ul class=" list-paddingleft-2" style="text-align: justify;">&lt;li>&lt;a target="_blank" href="http://www.tuicool.com/articles/jMzqYzF">http://www.tuicool.com/articles/jMzqYzF&lt;/a>&lt;/li>&lt;li>&lt;a target="_blank" href="http://stackoverflow.com/questions/4042905/what-is-main-py">http://stackoverflow.com/questions/4042905/what-is-main-py&lt;/a>&lt;/li>&lt;/ul>&lt;p>&lt;br>&lt;/p></p></div></article></main></div></div><footer class=footer><div class="container footer__container flex"><div class=footer__copyright>&copy; 2026 臭大佬博客.
<span class=footer__copyright-credits>基于 <a href=https://gohugo.io/ rel="nofollow noopener" target=_blank>Hugo</a> 引擎和 <a href=https://github.com/Vimux/Mainroad/ rel="nofollow noopener" target=_blank>Mainroad</a> 主题</span></div></div></footer></div><script async defer src=/js/menu.js></script></body></html>